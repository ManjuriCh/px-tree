<!--
  Relative paths assume component is being run from inside an app or another component, where dependencies are flat
  siblings. When this component is run from its own repo (e.g. tests, examples), we assume the server is started with
  'gulp serve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-tree-view-behaviors.html">
<link rel="import" href="px-tree-view-node.html">


<!--
Element renders a generic tree view.

##### Usage
```  
  <px-tree-view items='[{"label":"Label","items":[{"label":"Child"}]}]'></px-tree-view>
```

### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-tree-view-background` | Background color for an individual node | `$gray8`
`--px-tree-view-background--hover` | Background color for an individual node (hover state) | `$gray10`
`--px-tree-view-background--selected` | Background selected color for an individual node (selected state) | `$gray7`
`--px-tree-view-toggle` | Branch toggle color | `$gray4`
`--px-tree-view-toggle--hover` | Branch toggle color (hover state) | `$white`
`--px-tree-view-toggle--selected` | Branch toggle color (selected state) | `$white`
`--px-tree-view-icon` | Icon color | `$white`
`--px-tree-view-icon--hover` | Icon color (hover state) | `$white`
`--px-tree-view-icon--selected` | Icon color (selected state) | `$white`
`--px-tree-view-icon-border` | Icon border color | `$gray4`
`--px-tree-view-icon-border--hover` | Icon border color (hover state) | `$gray4`
`--px-tree-view-icon-border--selected` | Icon border color (selected state) | `$gray4`
`--px-tree-view-border` | Border color for an individual node | `$gray9`
`--px-tree-view-border--hover` | Border color for an individual node (hover state) | `$gray9`
`--px-tree-view-border--selected` | Border selected color for an individual node (selected state) | `$gray9`
`--px-tree-view-text` | Text color for an individual node | `$white`
`--px-tree-view-text--hover` | Text color for an individual node (hover state) | `$white`
`--px-tree-view-text--selected` | Text color for an individual node (selected state) | `$white`
`--px-tree-view-branch-text` | Text color for an individual branch | `$gray4`
`--px-tree-view-branch-text--hover` | Text color for an individual branch (hover state) | `$white`
`--px-tree-view-branch-text--selected` | Text color for an individual branch (selected state) | `$white`

@element px-tree-view
@blurb Generic tree-vew component
@homepage index.html
@demo index.html
-->
<link rel="import" href="css/px-tree-view-styles.html">
<link rel="import" href="../px-theme/px-theme-styles.html">

<dom-module id="px-tree-view">
  <template>
    <style include="px-tree-view-styles"></style>
    <style include="px-theme-styles"></style>
    
    <div class="tree-view">
      <px-tree-view-node items="[[ items ]]"></px-tree-view-node>
    </div>
  </template>
</dom-module>

<script>
/**
 * Fires every time a new node is inserted into the tree or any one of the branches.
 * @event px-tree-view-insert
 */

/**
 * Fires every time a new node is inserted into a branch. 
 * @event px-tree-view-branch-insert
 */

/**
 * Fires when the flush method is called. This is fired on the tree, branch or leaf level.
 * @event px-tree-view-flush
 */

/**
 * Fires when the flush method is called on the tree root only.
 * @event px-tree-view-tree-flush
 */

/**
 * Fires when a node is tapped. This is fired on the tree or branch level.
 * @event px-tree-view-tap
 */

/**
 * Fires when a branch is tapped.
 * @event px-tree-view-branch-tap
 */

/**
 * Fires when a leaf is tapped.
 * @event px-tree-view-leaf-tap
 */

/**
 * Fires when a node is pressed/onmousedown. This is fired on the tree or branch level.
 * @event px-tree-view-press
 */

/**
 * Fires when a branch is pressed/onmousedown.
 * @event px-tree-view-branch-press
 */

/**
 * Fires when a leaf is pressed/onmousedown.
 * @event px-tree-view-leaf-press
 */

/**
 * Fires when a node is released/onmouseup. This is fired on the tree or branch level.
 * @event px-tree-view-release
 */

/**
 * Fires when a branch is released/onmouseup.
 * @event px-tree-view-branch-release
 */

/**
 * Fires when a leaf is released/onmouseup.
 * @event px-tree-view-leaf-release
 */

/**
 * Fires when a node is entered by the mouse. This is fired on the tree or branch level.
 * @event px-tree-view-enter
 */

/**
 * Fires when a branch is entered by the mouse.
 * @event px-tree-view-branch-enter
 */

/**
 * Fires when a leaf is entered by the mouse.
 * @event px-tree-view-leaf-enter
 */

/**
 * Fires when the mouse leaves the node. This is fired on the tree or branch level.
 * @event px-tree-view-leave
 */

/**
 * Fires when the mouse leaves the branch.
 * @event px-tree-view-branch-leave
 */

/**
 * Fires when the mouse leaves the leaf.
 * @event px-tree-view-leaf-leave
 */

/**
 * Fires when a node is removed. This is fired on the tree or branch level.
 * @event px-tree-view-remove
 */

/**
 * Fires when a branch is removed.
 * @event px-tree-view-branch-remove
 */

/**
 * Fires when a leaf is removed.
 * @event px-tree-view-leaf-remove
 */

/**
 * Fires when a branch expanded, but it's content is empty.
 * @event px-tree-view-empty
 */

/**
 * Fires when a branch is expanded.
 * @event px-tree-view-expand
 */

/**
 * Fires when a branch is collapsed.
 * @event px-tree-view-collapse
 */

/**
 * Fires when a branch state of expanded/collapsed is toggled.
 * @event px-tree-view-toggle
 */

/**
 * Fires when a node is selected. This is fired on the branch or leaf.
 * @event px-tree-view-select
 */

/**
 * Fires when a branch is selected.
 * @event px-tree-view-branch-select
 */

/**
 * Fires when a leaf is selected.
 * @event px-tree-view-leaf-select
 */

/**
 * Fires when a node is deselected. This is fired on the branch or leaf.
 * @event px-tree-view-deselect
 */

/**
 * Fires when a branch is deselected.
 * @event px-tree-view-branch-deselect
 */

/**
 * Fires when a leaf is deselected.
 * @event px-tree-view-leaf-deselect
 */

/**
 * Fires when a node is disabled. This is fired on the branch and leaf.
 * @event px-tree-view-disable
 */

/**
 * Fires when a branch is disabled.
 * @event px-tree-view-branch-disable
 */

/**
 * Fires when a leaf is disabled.
 * @event px-tree-view-leaf-disable
 */

/**
 * Fires when a node is enabled. This is fired on the branch and leaf.
 * @event px-tree-view-enable
 */

/**
 * Fires when a branch is enabled.
 * @event px-tree-view-branch-enable
 */

/**
 * Fires when a leaf is enabled.
 * @event px-tree-view-leaf-enable
 */

/* */

Polymer({
  is:'px-tree-view',
  behaviors:[Polymer.PX.TreeView],

  /**
   * @property properties
   * @type {Object}
   */
  properties:{
    /**
     * Full data structure of the tree. The object must be in a JSON format to be correctly parsed.
     * If not, it will not render the tree correctly. To create a nested branch in the tree, pass
     * the property items:[ ... ] in any node. The node assumes that, even if there's an empty array,
     * that this node is a branch and will display it as such. 
     * Example: { "label":"My Label", "items":[ { "label":"Leaf" }, { "label":"Branch", "items":[ ... ] } ] }
     * @property items
     * @type {Array}
     */
    items:{
      type:Array,
      value:function(){ return []; }
    },

    /**
     * This holds all of the selected nodes within the treeview. This array will
     * be populated as a user select or deselects a node within the tree. Do not attempt to set
     * the value of this to select nodes; this is a read-only property that can used to tell
     * what nodes are currently selected.
     * @public
     * @readOnly
     * @property selected
     * @type {Array}
     */
    selected:{
      type:Array,
      readOnly:true,
      value:function(){ return []; }
    },

    /**
     * If this attribute is added, only one node can be selected in the tree; regardless
     * of if the shift, meta, alt or ctrl key are pressed.
     * @public
     * @property single-select
     * @type {Boolean}
     */
    singleSelect:{
      type:Boolean,
      value:false
    },

    /**
     * If this property is added (no value needed), it will change the behavior of expanding a branch by
     * means of a double click, ranther than a single click.
     * @public
     * @property double-click-branches
     * @type {Boolean}
     */
    doubleClickBranches:{
      type:Boolean,
      value:false
    },

    /**
     * If this property is added (no value needed), it will disable the ability to select a branch
     * @public
     * @property disable-branch-select
     * @type {Boolean}
     */
    disableBranchSelect:{
      type:Boolean,
      value:false
    },

    /**
     * If this property is added (no value needed), this will render the tree in the lights-off (dark) theme
     * @public
     * @property lights-off
     * @type {Boolean}
     */
    lightsOff:{
      type:Boolean,
      value:false
    }
  },

  /**
   * Sets the selected state for a node in the tree.
   * @private
   * @param {Element} node Polymer component/element to push into the selected
   * @return {Void}
   */
  _select:function(node){
    this.selected.push(node);
  },

  /**
   * Sets the node state to deselected
   * @private
   * @param {Number} node Node or index to deselect
   * @return {Void}
   */
  _deselect:function(node){
    this.selected.splice(this.selected.indexOf(node),1);
  },

  /**
   * Removes the passed index from as a child
   * @private
   * @param {Number} index
   * @return {Void}
   */
  _remove:function(index){
    this.splice('items', index, 1);
    this._childnodes.splice(index, 1);

    this._each(this._childnodes, function(node,i){
      node.position=i;
    });
  },

  /**
   * Returns all of the details for an event
   * @private
   * @return {Object}
   */
  _detail:function(extras){
    var detail = {
      type:'branch',
      scope:this
    };

    if (extras){
      this._each(extras, function(extra,key){
        if (this._isundef(detail[key])){
          detail[key]=extra;
        }
      });
    }

    return detail;
  },




  /**
   * Returns a single child that exists in the root branch if an index is passed.
   * If the argument is undefined, all child nodes will be returned. If the argument
   * passed is an element and it's either a branch or leaf component, it will be returned.
   * @public
   * @param {Mixed} node (Optional) Numeric index of a child or a child element to return (passes through)
   * @return {Mixed} Element or array of elements
   */
  nodes:function(node){
    if (!this._childnodes){
      return [];
    }

    if (this._isundef(node)){
      return this._childnodes;
    }

    if (this._iselm(node)){
      return node;
    }

    return this._childnodes[node];
  },

  /**
   * Returns true if the node is a branch
   * @public
   * @param {Element} node
   * @return {Boolean}
   */
  isbranch:function(node){
    return node && node.is==='px-tree-view-branch';
  },

  /**
   * Returns true if the node is a leaf
   * @public
   * @param {Element} node
   * @return {Boolean}
   */
  isleaf:function(node){
    return node && node.is==='px-tree-view-leaf';
  },

  /**
   * Add a single or multiple items (an array of items) to the tree brower
   * @public
   * @param {Mixed} node Object with node information, or an array of objects to insert
   * @param {Mixed} after (Optional) Position or element to inject the node or nodes after
   * @return {Instance}
   */
  insert:function(node,after){
    if (this._isarray(node)){
      this._each(node, function(node,i){
        this.insert(node,(this._isundef(after) ? after : after+i));
      });
    }
    else {
      if (!this._isundef(after)){
        if (this._iselm(after)){
          this._each(this.items, function(child,i){
            if (child===after){
              after=i;
              return true;
            }
          });
        }

        this.splice('items', after+1, 0, node);
        this._childnodes.splice(after+1, 0, node);
        
        this.fire('px-tree-view-insert', this._detail({ data:node }));
      }
      else {
        this.push('items', node);
        this.fire('px-tree-view-insert', this._detail({ data:node }));
      }
    }

    return this;
  },

  /**
   * This will flush the data and visual child node component from the parent node by the 
   * index of the array (if an int is passed) or by the elelent of the child (if an element
   * is passed).
   * @public
   * @param {Mixed} node Node component or index of the component to remove
   * @return {Instance}
   */
  remove:function(node){
    if (this._iselm(node)){
      if (!this._isundef(node.position)){
        node.remove();
      }
    }
    else if (this._isnum(node)){
      node = this.nodes(node);

      if (this._iselm(node)){
        node.remove();
      }
    }

    return this;
  },

  /**
   * Flushes of all branches and leafs in the root of the tree.
   * @public
   * @return {Instance}
   */
  flush:function(){
    var node;

    if (this._childnodes){
      while(this._childnodes.length){
        node = this._last(this._childnodes);
        node.remove();
      }
    }

    this.fire('px-tree-view-flush', this._detail());
    this.fire('px-tree-view-tree-flush', this._detail());

    return this;
  },

  /**
   * Expands all items, or if an index is passed, only that child
   * will be expanded. Optionally an array can be passed to expand
   * multiple items at once.
   * @public
   * @param {Mixed} node (Optional) Index of child node to expand or array of child indexes to expand
   * @return {Instance}
   */
  expand:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.expand(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (node && node.expand){
        node.expand(node);
      }
    }
    else {
      this._each(this._childnodes, function(node){
        if (node.expand){
          node.expand();
        }
      });
    }

    return this;
  },

  /**
   * Collapses all items, or if an index is passed, only that child
   * will be collpased. Optionally an array can be passed to collapse
   * multiple items at once.
   * @public
   * @param {Mixed} node (Optional) Index of child node to collapse or array of child indexes to collapse
   * @return {Instance}
   */
  collapse:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.collapse(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (this.isbranch(node)){
        node.collapse(node);
      }
    }
    else {
      this._each(this._childnodes, function(node){
        if (this.isbranch(node)){
          node.collapse();
        }
      });
    }

    return this;
  },

  /**
   * Toggles the node state to expanded. If no argument is passed, all child nodes
   * will be toggled. If an index is passed, it will toggle only that child.
   * @public
   * @param {Mixed} node (Optional) Index of child node to toggle or array of child indexes to toggle
   * @return {Instance}
   */
  toggle:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.toggle(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (this.isbranch(node)){
        node.toggle(node);
      }
    }
    else {
      this._each(this._childnodes, function(node){
        if (this.isbranch(node)){
          node.toggle();
        }
      });
    }

    return this;
  },

  /**
   * Sets the node state to selected. If no argument is passed, all child nodes
   * will be selected. If an index is passed, it will deslect only that child.
   * @public
   * @param {Mixed} node (Optional) Index of child node to select or array of child indexes to select
   * @return {Instance}
   */
  select:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.select(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (node){
        node.select();
      }
    }
    else {
      this._each(this._childnodes, function(node){
        node.select();
      });
    }

    return this;
  },

  /**
   * Sets the node state to deselected. If no argument is passed, all child nodes
   * will be deselected. If an index is passed, it will deslect only that child.
   * @public
   * @param {Mixed} node (Optional) Index of child node to deselect or array of child indexes to deselect
   * @return {Instance}
   */
  deselect:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.deselect(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (node){
        node.deselect();
      }
    }
    else {
      this._each(this.selected.concat(), function(node){
        node.deselect();
      });
    }

    return this;
  },

  /**
   * Sets the node state to enabled. If no argument is passed, all child nodes
   * will be enabled. If an index is passed, it will deslect only that child.
   * @public
   * @param {Mixed} node (Optional) Index of child node to enable or array of child indexes to enable
   * @return {Instance}
   */
  enable:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.enable(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (node){
        node.enable();
      }
    }
    else {
      this._each(this._childnodes, function(node){
        node.enable();
      });
    }

    return this;
  },

  /**
   * Sets the node state to disabled. If no argument is passed, all child nodes
   * will be disabled. If an index is passed, it will deslect only that child.
   * @public
   * @param {Mixed} node (Optional) Index of child node to disable or array of child indexes to disable
   * @return {Instance}
   */
  disable:function(node){
    if (this._isarray(node)){
      this._each(node, function(i){
        this.disable(i);
      });
    }
    else if (this._isnum(node)){
      node=this.nodes(node);

      if (node){
        node.disable();
      }
    }
    else {
      this._each(this._childnodes, function(node){
        node.disable();
      });
    }

    return this;
  }
});
</script>
